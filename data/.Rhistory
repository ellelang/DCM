c( 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 ),
c( 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0 ),
c( 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0 ) )
SetObjPriority    <- c(3, 2, 2, 1)
SetObjWeight      <- c(1.0, 0.25, 1.25, 1.0)
# Initialize model
model             <- list()
model$modelsense  <- 'max'
model$modelname   <- 'multiobj'
# Set variables, all of them are binary, with 0,1 bounds.
model$vtype       <- 'B'
model$lb          <- 0
model$ub          <- 1
model$varnames    <- paste(rep('El', groundSetSize), 1:groundSetSize, sep='')
# Build constraint matrix
model$A           <- spMatrix(1, groundSetSize,
i = rep(1,groundSetSize),
j = 1:groundSetSize,
x = rep(1,groundSetSize))
model$rhs         <- c(Budget)
model$sense       <- c('<')
model$constrnames <- c('Budget')
# Set multi-objectives
model$multiobj          <- list()
for (m in 1:nSubSets) {
model$multiobj[[m]]          <- list()
model$multiobj[[m]]$objn     <- Set[[m]]
model$multiobj[[m]]$priority <- SetObjPriority[m]
model$multiobj[[m]]$weight   <- SetObjWeight[m]
model$multiobj[[m]]$abstol   <- m
model$multiobj[[m]]$reltol   <- 0.01
model$multiobj[[m]]$name     <- sprintf('Set%d', m)
model$multiobj[[m]]$con      <- 0.0
}
# Save model
gurobi_write(model,'multiobj_R.lp')
# Set parameters
params               <- list()
params$PoolSolutions <- 100
# Optimize
result <- gurobi(model, params)
# Capture solution information
if (result$status != 'OPTIMAL') {
cat('Optimization finished with status', result$status, '\n')
stop('Stop now\n')
}
# Print best solution
cat('Selected elements in best solution:\n')
for (e in 1:groundSetSize) {
if(result$x[e] < 0.9) next
cat(' El',e,sep='')
}
cat('\n')
# Iterate over the best 10 solutions
if ('pool' %in% names(result)) {
solcount <- length(result$pool)
cat('Number of solutions found:', solcount, '\n')
if (solcount > 10) {
solcount <- 10
}
cat('Objective values for first', solcount, 'solutions:\n')
for (k in 1:solcount) {
cat('Solution', k, 'has objective:', result$pool[[k]]$objval[1], '\n')
}
} else {
solcount <- 1
cat('Number of solutions found:', solcount, '\n')
cat('Solution 1 has objective:', result$objval, '\n')
}
result
result
model
PoolSolutions
library(gurobi)
model <- list()
matrix(c(1,2,3,1,1,0), nrow=2, ncol=3, byrow=T)
model <- list()
matrix(c(1,2,3,1,1,0), nrow=2, ncol=3, byrow=T)
model$A          <- matrix(c(1,2,3,1,1,0), nrow=2, ncol=3, byrow=T)
model$obj        <- c(1,1,2)
model$modelsense <- 'max'
model$rhs        <- c(4,1)
model$sense      <- c('<', '>')
model$vtype      <- 'B'
params <- list(OutputFlag=0)
result <- gurobi(model, params)
print('Solution:')
print(result$objval)
print(result$x)
model <- list()
matrix(c(1,2,3,1,1,0), nrow=2, ncol=3, byrow=T)
model$A          <- matrix(c(1,2,3,1,1,0), nrow=2, ncol=3, byrow=T)
model$obj        <- c(1,1,2)
model$modelsense <- 'max'
model$rhs        <- c(4,1)
model$sense      <- c('<', '>')
model$vtype      <- 'B'
params <- list(OutputFlag=0)
result <- gurobi(model, params)
print('Solution:')
print(result$objval)
print(result$x)
# Want to cover three different sets but subject to a common budget of
# elements allowed to be used. However, the sets have different priorities to
# be covered; and we tackle this by using multi-objective optimization.
library(Matrix)
library(gurobi)
# define primitive data
groundSetSize     <- 20
nSubSets          <- 4
Budget            <- 12
Set               <- list(
c( 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),
c( 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 ),
c( 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0 ),
c( 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0 ) )
SetObjPriority    <- c(3, 2, 2, 1)
SetObjWeight      <- c(1.0, 0.25, 1.25, 1.0)
# Initialize model
model             <- list()
model$modelsense  <- 'max'
model$modelname   <- 'multiobj'
# Set variables, all of them are binary, with 0,1 bounds.
model$vtype       <- 'B'
model$lb          <- 0
model$ub          <- 1
model$varnames    <- paste(rep('El', groundSetSize), 1:groundSetSize, sep='')
# Build constraint matrix
model$A           <- spMatrix(1, groundSetSize,
i = rep(1,groundSetSize),
j = 1:groundSetSize,
x = rep(1,groundSetSize))
model$rhs         <- c(Budget)
model$sense       <- c('<')
model$constrnames <- c('Budget')
# Set multi-objectives
model$multiobj          <- list()
for (m in 1:nSubSets) {
model$multiobj[[m]]          <- list()
model$multiobj[[m]]$objn     <- Set[[m]]
model$multiobj[[m]]$priority <- SetObjPriority[m]
model$multiobj[[m]]$weight   <- SetObjWeight[m]
model$multiobj[[m]]$abstol   <- m
model$multiobj[[m]]$reltol   <- 0.01
model$multiobj[[m]]$name     <- sprintf('Set%d', m)
model$multiobj[[m]]$con      <- 0.0
}
# Save model
gurobi_write(model,'multiobj_R.lp')
model
# Set parameters
params               <- list()
params$PoolSolutions <- 100
# Optimize
result <- gurobi(model, params)
# Capture solution information
if (result$status != 'OPTIMAL') {
cat('Optimization finished with status', result$status, '\n')
stop('Stop now\n')
}
# Print best solution
cat('Selected elements in best solution:\n')
for (e in 1:groundSetSize) {
if(result$x[e] < 0.9) next
cat(' El',e,sep='')
}
cat('\n')
# Iterate over the best 10 solutions
if ('pool' %in% names(result)) {
solcount <- length(result$pool)
cat('Number of solutions found:', solcount, '\n')
if (solcount > 10) {
solcount <- 10
}
cat('Objective values for first', solcount, 'solutions:\n')
for (k in 1:solcount) {
cat('Solution', k, 'has objective:', result$pool[[k]]$objval[1], '\n')
}
} else {
solcount <- 1
cat('Number of solutions found:', solcount, '\n')
cat('Solution 1 has objective:', result$objval, '\n')
}
result$objval
result$X
result$x
# Copyright 2018, Gurobi Optimization, LLC
#
# Assign workers to shifts; each worker may or may not be available on a
# particular day. If the problem cannot be solved, use IIS iteratively to
# find all conflicting constraints.
library(Matrix)
library(gurobi)
# Function to display results
printsolution <- function(result) {
if(result$status == 'OPTIMAL') {
cat('The optimal objective is',result$objval,'\n')
cat('Schedule:\n')
for (s in 1:nShifts) {
cat('\t',Shifts[s],':')
for (w in 1:nWorkers) {
if (result$x[varIdx(w,s)] > 0.9) cat(Workers[w],' ')
}
cat('\n')
}
}
}
# define data
nShifts  <- 14
nWorkers <-  7
nVars    <- nShifts * nWorkers
varIdx   <- function(w,s) {s+(w-1)*nShifts}
Shifts  <- c('Mon1', 'Tue2', 'Wed3', 'Thu4', 'Fri5', 'Sat6', 'Sun7',
'Mon8', 'Tue9', 'Wed10', 'Thu11', 'Fri12', 'Sat13', 'Sun14')
Workers <- c( 'Amy', 'Bob', 'Cathy', 'Dan', 'Ed', 'Fred', 'Gu' )
pay     <- c(10, 12, 10, 8, 8, 9, 11 )
shiftRequirements <- c(3, 2, 4, 4, 5, 6, 5, 2, 2, 3, 4, 6, 7, 5 )
availability <- list( c( 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1 ),
c( 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0 ),
c( 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 ),
c( 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1 ),
c( 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1 ),
c( 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1 ),
c( 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ) )
# Set-up environment
env <- list()
env$logfile <- 'workforce2.log'
# Build model
model            <- list()
model$modelname  <- 'workforce2'
model$modelsense <- 'min'
# Initialize assignment decision variables:
#    x[w][s] == 1 if worker w is assigned
#    to shift s. Since an assignment model always produces integer
#    solutions, we use continuous variables and solve as an LP.
model$lb       <- 0
model$ub       <- rep(1, nVars)
model$obj      <- rep(0, nVars)
model$varnames <- rep('',nVars)
for (w in 1:nWorkers) {
for (s in 1:nShifts) {
model$varnames[varIdx(w,s)] = paste0(Workers[w],'.',Shifts[s])
model$obj[varIdx(w,s)]      = pay[w]
if (availability[[w]][s] == 0) model$ub[varIdx(w,s)] = 0
}
}
# Set-up shift-requirements constraints
model$A           <- spMatrix(nShifts,nVars,
i = c(mapply(rep,1:nShifts,nWorkers)),
j = mapply(varIdx,1:nWorkers,
mapply(rep,1:nShifts,nWorkers)),
x = rep(1,nShifts * nWorkers))
model$sense       <- rep('=',nShifts)
model$rhs         <- shiftRequirements
model$constrnames <- Shifts
# Save model
gurobi_write(model,'workforce2.lp', env)
# Optimize
result <- gurobi(model, env = env)
# Display results
if (result$status == 'OPTIMAL') {
# The code may enter here if you change some of the data... otherwise
# this will never be executed.
printsolution(result);
} else if (result$status == 'INFEASIBLE') {
# We will loop until we reduce a model that can be solved
numremoved <- 0
while(result$status == 'INFEASIBLE') {
iis               <- gurobi_iis(model, env = env)
keep              <- (!iis$Arows)
cat('Removing rows',model$constrnames[iis$Arows],'...\n')
model$A           <- model$A[keep,,drop = FALSE]
model$sense       <- model$sense[keep]
model$rhs         <- model$rhs[keep]
model$constrnames <- model$constrnames[keep]
numremoved        <- numremoved + 1
gurobi_write(model, paste0('workforce2-',numremoved,'.lp'), env)
result            <- gurobi(model, env = env)
}
printsolution(result)
rm(iis)
} else {
# Just to handle user interruptions or other problems
cat('Unexpected status',result$status,'\nEnding now\n')
}
# Copyright 2018, Gurobi Optimization, LLC
#
# Want to cover three different sets but subject to a common budget of
# elements allowed to be used. However, the sets have different priorities to
# be covered; and we tackle this by using multi-objective optimization.
library(Matrix)
library(gurobi)
# define primitive data
groundSetSize     <- 20
nSubSets          <- 4
Budget            <- 12
Set               <- list(
c( 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),
c( 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 ),
c( 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0 ),
c( 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0 ) )
SetObjPriority    <- c(3, 2, 2, 1)
SetObjWeight      <- c(1.0, 0.25, 1.25, 1.0)
# Initialize model
model             <- list()
model$modelsense  <- 'max'
model$modelname   <- 'multiobj'
# Set variables, all of them are binary, with 0,1 bounds.
model$vtype       <- 'B'
model$lb          <- 0
model$ub          <- 1
model$varnames    <- paste(rep('El', groundSetSize), 1:groundSetSize, sep='')
# Build constraint matrix
model$A           <- spMatrix(1, groundSetSize,
i = rep(1,groundSetSize),
j = 1:groundSetSize,
x = rep(1,groundSetSize))
model$rhs         <- c(Budget)
model$sense       <- c('<')
model$constrnames <- c('Budget')
# Set multi-objectives
model$multiobj          <- list()
for (m in 1:nSubSets) {
model$multiobj[[m]]          <- list()
model$multiobj[[m]]$objn     <- Set[[m]]
model$multiobj[[m]]$priority <- SetObjPriority[m]
model$multiobj[[m]]$weight   <- SetObjWeight[m]
model$multiobj[[m]]$abstol   <- m
model$multiobj[[m]]$reltol   <- 0.01
model$multiobj[[m]]$name     <- sprintf('Set%d', m)
model$multiobj[[m]]$con      <- 0.0
}
# Save model
gurobi_write(model,'multiobj_R.lp')
model
# Set parameters
params               <- list()
params$PoolSolutions <- 100
# Optimize
result <- gurobi(model, params)
# Capture solution information
if (result$status != 'OPTIMAL') {
cat('Optimization finished with status', result$status, '\n')
stop('Stop now\n')
}
# Print best solution
cat('Selected elements in best solution:\n')
for (e in 1:groundSetSize) {
if(result$x[e] < 0.9) next
cat(' El',e,sep='')
}
cat('\n')
# Iterate over the best 10 solutions
if ('pool' %in% names(result)) {
solcount <- length(result$pool)
cat('Number of solutions found:', solcount, '\n')
if (solcount > 10) {
solcount <- 10
}
cat('Objective values for first', solcount, 'solutions:\n')
for (k in 1:solcount) {
cat('Solution', k, 'has objective:', result$pool[[k]]$objval[1], '\n')
}
} else {
solcount <- 1
cat('Number of solutions found:', solcount, '\n')
cat('Solution 1 has objective:', result$objval, '\n')
}
result$objval
result$x
install.packages("blogdown")
blogdown::install_hugo()
install.packages("glmnet")
data_eco <- read.csv(file = "fscore_eco.csv")
setwd("C:/Users/langzx/Desktop/github/DCM/data")
data_eco <- read.csv(file = "fscore_eco.csv")
ibrary(dplyr)
library(ggplot2)
library(purrr)
library(dplyr)
library(ggplot2)
library(purrr)
library(tibble)
library(tidyr)
colnames(data_eco)
df <- data_eco[,-1]
head(df)
df <- data_eco[,-"id"]
head(df)
df <- data_eco[,seq(1,8,1)]
head(df)
df_impute <- sapply(df,function(x) {
if(is.numeric(x)) ifelse(is.na(x),median(x,na.rm=T),x) else x})
df_impute
k2 <- kmeans(df_impute, centers = 2, nstart = 25)
k2
library(cluster)
set.seed(123)
# function to compute total within-cluster sum of square
wss <- function(k) {
kmeans(df_impute, k, nstart = 10 )$tot.withinss
}
# Compute and plot wss for k = 1 to k = 5
k.values <- 1:5
# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)
plot(k.values, wss_values,
type="b", pch = 19, frame = FALSE,
xlab="Number of clusters K",
ylab="Total within-clusters sum of squares")
fviz_nbclust(df_impute, kmeans, method = "wss")
library(factoextra)
install.packages("factoextra")
library(factoextra)
fviz_nbclust(df_impute, kmeans, method = "wss")
dist.eucl <- dist(df_impute, method = "euclidean")
# Subset the first 3 columns and rows and Round the values
round(as.matrix(dist.eucl)[1:3, 1:3], 1)
# Subset the first 3 columns and rows and Round the values
round(as.matrix(dist.eucl)[1:3, 1:8], 1)
dist.cor <- get_dist(df_impute, method = "pearson")
# Display a subset
round(as.matrix(dist.cor)[1:3, 1:8], 1)
fviz_dist(dist.eucl)
k2 <- kmeans(df_impute, centers = 4, nstart = 25)
k2$cluster
data_lm <- read.csv(file = "fscore_lm.csv")
colnames(data_eco)
colnames(data_lm)
df_impute_lm <- sapply(df_lm,function(x) {
if(is.numeric(x)) ifelse(is.na(x),median(x,na.rm=T),x) else x})
df_lm <- data_lm[,seq(1,11,1)]
head(df_lm)
df_impute_lm <- sapply(df_lm,function(x) {
if(is.numeric(x)) ifelse(is.na(x),median(x,na.rm=T),x) else x})
k_lm <- kmeans(df_impute, centers = 2, nstart = 25)
k_lm$cluster
set.seed(123)
fviz_nbclust(df_impute_lm, kmeans, method = "wss")
data_vl <- read.csv(file = "fscore_vl.csv")
colnames(data_vl)
df_vl <- data_vl[,seq(1,5,1)]
head(df_lm)
head(df_vl)
data_vl <- read.csv(file = "fscore_vl.csv")
colnames(data_vl)
df_vl <- data_vl[,seq(1,5,1)]
head(df_vl)
df_impute_vl <- sapply(df_vl,function(x) {
if(is.numeric(x)) ifelse(is.na(x),median(x,na.rm=T),x) else x})
set.seed(123)
fviz_nbclust(df_impute_vl, kmeans, method = "wss")
fviz_nbclust(df_impute_lm, kmeans, method = "wss")
fviz_nbclust(df_impute_vl, clara, method = "silhouette")+
theme_classic()
fviz_nbclust(df_impute, clara, method = "silhouette")+
theme_classic()
fviz_nbclust(df_impute_lm, clara, method = "silhouette")+
theme_classic()
res.dist_eco <- dist(df_impute, method = "euclidean")
res.hc_eco <- hclust(d = res.dist_eco, method = "ward.D2")
fviz_dend(res.hc_eco, cex = 0.5)
k2 <- kmeans(df_impute, centers = 4, nstart = 50)
k2$cluster
fviz_nbclust(df_impute, kmeans, method = "wss")
k_eco <- kmeans(df_impute, centers = 4, nstart = 50)
k_eco$cluster
cluster_eco <- k_eco$cluster
k_lm <- kmeans(df_impute, centers = 5, nstart = 25)
k_lm$cluster
fviz_nbclust(df_impute_vl, kmeans, method = "wss")
fviz_nbclust(df_impute_vl, clara, method = "silhouette")+
theme_classic()
set.seed(123)
fviz_nbclust(df_impute_vl, kmeans, method = "wss")
k_vl <- kmeans(df_impute_vl, centers = 3, nstart = 25)
k_vl$cluster
data.frame(data_eco$id)
dat <- data.frame(data_eco$id) %>% mutate(
c_eco = cluster_eco,
c_lm = cluster_lm,
c_vl = cluster_vl
)
cluster_lm <- k_lm$cluster
cluster_vl <- k_vl$cluster
dat <- data.frame(data_eco$id) %>% mutate(
c_eco = cluster_eco,
c_lm = cluster_lm,
c_vl = cluster_vl
)
dat
data_wta <- read.csv("wta_fscores10202019.csv")
data_wta$id
dat
data_wta <- data_wta %>% left_join(dat, by = c("id" = "data_eco.id"))
write.csv(x =data_wta , file = "wta_cluster_01222020.csv", row.names = FALSE)
hist(df$F1)
hist(df$F2)
hist(df$F3)
hist(df$F4)
hist(df$F5)
hist(df$F6)
hist(df$F7)
hist(df$F8)
k_eco <- kmeans(df_impute, centers = 3, nstart = 50)
fviz_cluster(k_eco, data = df_impute,
palette = c("#2E9FDF", "#00AFBB", "#E7B800"),
ellipse.type = "euclid", # Concentration ellipse
star.plot = TRUE, # Add segments from centroids to items
repel = TRUE, # Avoid label overplotting (slow)
ggtheme = theme_minimal()
)
